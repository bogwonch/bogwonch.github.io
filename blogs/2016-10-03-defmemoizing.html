<!DOCTYPE html><html><head><meta charset="utf-8"><title>Memoization</title><meta content="width=device-width,initial-scale=1" name="viewport"><style type=text/css>*{font-family:inherit;font-size:inherit;color:inherit;background-color:inherit;text-color:inherit;line-height:inherit}body{margin-left:0;margin-right:0;margin-top:0;padding:0;font-family:"Source Sans Pro",sans-serif;font-size:20px;line-height:1.5}body header{margin-top:0;padding:0;background-color:#bf360c;width:100%;color:#fff;height:60px;line-height:3}body header ul li{display:inline-block}body code{text-align:left;font-family:"PragmataPro",monospace}body code .kw{font-style:italic}body code .fu{font-weight:bold}body section{margin-left:5%;margin-right:5%}body section article{width:90%;margin:0 auto}body section article a{color:#bf360c}body section article a:visited{color:#000}body section article div.sourceCode{width:90%;display:block;margin-left:auto;margin-right:auto;overflow-x:scroll;white-space:nowrap}body section article div.sourceCode pre{display:inline}body section article img{width:60%;display:block;margin-left:auto;margin-right:auto}
  /*# sourceMappingURL=stylesheet.css.map */</style><body><header name=top><ul><h1>‚ù° <a class=title href="/">bogwonch.net</a></h1></header><section><article><p><a href=https://en.wikipedia.org/wiki/Memoization>Memoization</a> is a simple optimization trick. The basic trick is that for an algorithm you store previously computed results in a table. The input is the key; the result from the algorithm the output. You only compute the result if you haven't calculated it before.</p><p>A simple implementation of it might look something like:</p><pre class=lisp><code>(let ((results (make-hash-table)))
  (defun my-random (n)
    (multiple-value-bind (result found) (gethash n results)
      (if found
        result
        (let ((result (random n)))
          (setf (gethash n results) result)
          result)))))</code></pre><p>There is a fair bit of boilerplate just to do the memoization, and it obscures what the algorithm is. But this is <em>lisp</em>. The biggest argument for lisp is that we can change the language with macros. So lets define a version of function definition that automatically memoizes its program.</p><pre class=lisp><code>(defmacro defmemoizing (fn args &amp;body body)
  (let ((table (gensym "table"))
        (result (gensym "result"))
        (found (gensym "found"))
        (fn-table (intern (format nil "~:@(~a-table~)" `,fn))))
    `(let ((,table (make-hash-table :test #'equal)))
       (defun ,fn ,args
         (multiple-value-bind (,result ,found) (gethash (list ,@args) ,table)
           (if ,found
               ,result
             (progn
               (let ((,result (progn ,@body)))
                 (setf (gethash (list ,@args) ,table) ,result)
                 ,result)))))
       (defun ,fn-table ()
         ,table))))</code></pre><p>Not the most efficient thing in the world, but it works. The macro defines two functions: the function we ask it to define, another that lets us into the closure and get at the table. It has a few limitations, namely that I don't handle multiple values.</p><p>For examples of use:</p><pre class=lisp><code>(defmemoizing my-memoized-random (n) (random n))
(defmemoizing factorial (n)
  (cond
   ((eql n 0) 1)
   ((eql n 1) 1)
   (t (* n (factorial (1- n))))))
(defmemoizing fib (n)
  (cond
   ((&lt; n 2) 1)
   (t (+ (fib (1- n)) (fib (- n 2))))))
(defmemoizing factorial (n)
  (cond ((eql n 0) 1)</code></pre><p>Looks just like normal function definitions, right?</p><pre class=lisp><code>* (my-memoized-random 10)
6
* (my-memoized-random 10)
6
* (my-memoized-random 10)
6
* (my-memoized-random 10)
6</code></pre><p>A-ha!<br>Side effects are gone. Since we don't bother to recompute the results, we never get another random number (for that input).</p><pre class=lisp><code>* (fib 10)
89
* (loop for k being the hash-key
        using (hash-value v) of (fib-table) 
        do (format t "~a -&gt; ~a~%" k v))
(1) -&gt; 1
(0) -&gt; 1
(2) -&gt; 2
(3) -&gt; 3
(4) -&gt; 5
(5) -&gt; 8
(6) -&gt; 13
(7) -&gt; 21
(8) -&gt; 34
(9) -&gt; 55
(10) -&gt; 89
NIL</code></pre><p>For the recursive function we also got all the intermediate results saved.</p><p>I love this example. It shows the power of lisp's macros. I do not think you could do this sort of trick trivially in many other languages.</p></article></section>

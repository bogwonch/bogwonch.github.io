<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Memoization</title>
    <!-- <link rel=stylesheet href="/stylesheet.css"> -->
  </head>
  
  <body>
    <header name=top>
      <ul>
        </li><h1>‚ù° <a class="title" href="/">bogwonch.net</a></h1></li>
      <ul>
    </header>

    <section>
      <article>
      <ul id=keywords>
      </ul>
  
<p><a href="https://en.wikipedia.org/wiki/Memoization">Memoization</a> is a simple optimization trick. The basic trick is that for an algorithm you store previously computed results in a table. The input is the key; the result from the algorithm the output. You only compute the result if you haven't calculated it before.</p>
<p>A simple implementation of it might look something like:</p>
<div class="sourceCode"><pre class="sourceCode lisp"><code class="sourceCode commonlisp">(<span class="kw">let</span> ((results (<span class="kw">make-hash-table</span>)))
  (<span class="kw">defun</span><span class="fu"> my-random </span>(n)
    (<span class="kw">multiple-value-bind</span> (result found) (<span class="kw">gethash</span> n results)
      (<span class="kw">if</span> found
        result
        (<span class="kw">let</span> ((result (<span class="kw">random</span> n)))
          (<span class="kw">setf</span> (<span class="kw">gethash</span> n results) result)
          result)))))</code></pre></div>
<p>There is a fair bit of boilerplate just to do the memoization, and it obscures what the algorithm is. But this is <em>lisp</em>. The biggest argument for lisp is that we can change the language with macros. So lets define a version of function definition that automatically memoizes its program.</p>
<div class="sourceCode"><pre class="sourceCode lisp"><code class="sourceCode commonlisp">(<span class="kw">defmacro</span><span class="fu"> defmemoizing </span>(fn args &amp;body body)
  (<span class="kw">let</span> ((table (<span class="kw">gensym</span> <span class="st">&quot;table&quot;</span>))
        (result (<span class="kw">gensym</span> <span class="st">&quot;result&quot;</span>))
        (found (<span class="kw">gensym</span> <span class="st">&quot;found&quot;</span>))
        (fn-table (<span class="kw">intern</span> (<span class="kw">format</span> <span class="kw">nil</span> <span class="st">&quot;~:@(~a-table~)&quot;</span> `,fn))))
    `(<span class="kw">let</span> ((,table (<span class="kw">make-hash-table</span> <span class="kw">:test</span> #&#39;equal)))
       (<span class="kw">defun</span><span class="fu"> </span>,fn ,args
         (<span class="kw">multiple-value-bind</span> (,result ,found) (<span class="kw">gethash</span> (<span class="kw">list</span> ,@args) ,table)
           (<span class="kw">if</span> ,found
               ,result
             (<span class="kw">progn</span>
               (<span class="kw">let</span> ((,result (<span class="kw">progn</span> ,@body)))
                 (<span class="kw">setf</span> (<span class="kw">gethash</span> (<span class="kw">list</span> ,@args) ,table) ,result)
                 ,result)))))

       (<span class="kw">defun</span><span class="fu"> </span>,fn-table ()
         ,table))))</code></pre></div>
<p>Not the most efficient thing in the world, but it works. The macro defines two functions: the function we ask it to define, another that lets us into the closure and get at the table. It has a few limitations, namely that I don't handle multiple values.</p>
<p>For examples of use:</p>
<div class="sourceCode"><pre class="sourceCode lisp"><code class="sourceCode commonlisp">(defmemoizing my-memoized-random (n) (<span class="kw">random</span> n))

(defmemoizing factorial (n)
  (<span class="kw">cond</span>
   ((<span class="kw">eql</span> n <span class="dv">0</span>) <span class="dv">1</span>)
   ((<span class="kw">eql</span> n <span class="dv">1</span>) <span class="dv">1</span>)
   (<span class="kw">t</span> (<span class="kw">*</span> n (factorial (<span class="kw">1-</span> n))))))

(defmemoizing fib (n)
  (<span class="kw">cond</span>
   ((<span class="kw">&lt;</span> n <span class="dv">2</span>) <span class="dv">1</span>)
   (<span class="kw">t</span> (<span class="kw">+</span> (fib (<span class="kw">1-</span> n)) (fib (<span class="kw">-</span> n <span class="dv">2</span>))))))

(defmemoizing factorial (n)
  (<span class="kw">cond</span> ((<span class="kw">eql</span> n <span class="dv">0</span>) <span class="dv">1</span>)</code></pre></div>
<p>Looks just like normal function definitions, right?</p>
<div class="sourceCode"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span class="kw">*</span> (my-memoized-random <span class="dv">10</span>)
<span class="dv">6</span>
<span class="kw">*</span> (my-memoized-random <span class="dv">10</span>)
<span class="dv">6</span>
<span class="kw">*</span> (my-memoized-random <span class="dv">10</span>)
<span class="dv">6</span>
<span class="kw">*</span> (my-memoized-random <span class="dv">10</span>)
<span class="dv">6</span></code></pre></div>
<p>A-ha!<br />
Side effects are gone. Since we don't bother to recompute the results, we never get another random number (for that input).</p>
<div class="sourceCode"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span class="kw">*</span> (fib <span class="dv">10</span>)
<span class="dv">89</span>
<span class="kw">*</span> (<span class="kw">loop</span> for k being <span class="kw">the</span> hash-key
        using (hash-value v) of (fib-table) 
        <span class="kw">do</span> (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;~a -&gt; ~a~%&quot;</span> k v))
(<span class="dv">1</span>) -&gt; <span class="dv">1</span>
(<span class="dv">0</span>) -&gt; <span class="dv">1</span>
(<span class="dv">2</span>) -&gt; <span class="dv">2</span>
(<span class="dv">3</span>) -&gt; <span class="dv">3</span>
(<span class="dv">4</span>) -&gt; <span class="dv">5</span>
(<span class="dv">5</span>) -&gt; <span class="dv">8</span>
(<span class="dv">6</span>) -&gt; <span class="dv">13</span>
(<span class="dv">7</span>) -&gt; <span class="dv">21</span>
(<span class="dv">8</span>) -&gt; <span class="dv">34</span>
(<span class="dv">9</span>) -&gt; <span class="dv">55</span>
(<span class="dv">10</span>) -&gt; <span class="dv">89</span>
NIL</code></pre></div>
<p>For the recursive function we also got all the intermediate results saved.</p>
<p>I love this example. It shows the power of lisp's macros. I do not think you could do this sort of trick trivially in many other languages.</p>

        <noscript id="deferred-styles">
          <link rel="stylesheet" type="text/css" href="/stylesheet.css"/>
        </noscript>
        <script>
          var loadDeferredStyles = function() {
            var addStylesNode = document.getElementById("deferred-styles");
            var replacement = document.createElement("div");
            replacement.innerHTML = addStylesNode.textContent;
            document.body.appendChild(replacement)
            addStylesNode.parentElement.removeChild(addStylesNode);
          };
          var raf = requestAnimationFrame || mozRequestAnimationFrame ||
              webkitRequestAnimationFrame || msRequestAnimationFrame;
          if (raf) raf(function() { window.setTimeout(loadDeferredStyles, 0); });
          else window.addEventListener('load', loadDeferredStyles);
        </script>
      </article>
    </section>
  </body>
</html>

